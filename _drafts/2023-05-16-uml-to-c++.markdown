---
layout: single
toc: false
title:  "UML to C++"
date:   2023-05-16 06:00:10 +0200
categories: Software-Design
comments: true
---
{:refdef: style="text-align: center;padding: 20px"}

Ein UML-Klassendiagramm stellt die verschiedenen Klassen in einem System, ihre Attribute, Operationen und ihre Beziehungen zueinader dar. Bei richtiger Anwendung vermittelt UML präzise, wie Code aus Diagrammen implementiert werden sollte. Das Kernelement für eine korrekte Interpretation hierbei sind die Beziehungen der Klassen zueinander. 

Im folgenden stelle ich wichtigsten Beziehungstypen in UML Klassen-Diagrammen dar. Jede Beziehung wird kurz erklärt, danach folgt ein Alltagsbeispiel um die Beziehung mit physikalisch greifbaren Objekten zu veranschaulichen und letzlich wird ein Abschnitt mit einem C++ Codebeispiel abgeschlossen.

Die Intention dieses Artikels ist es, auch "Code-lastigen" Menschen, wie z.B. mir, klar zu machen wie  ein UML-Diagram in Code realisiert wird. Er wendet sich daher an Entwickler die mit Klassendiagrammen schon Erfahrung haben. Allerdings glaube ich das auch Anfänger davon profitieren können wie ein Klassendiagramm letzlich in Code realisiert wird.

# Assoziation 

Bei einer Assoziation handelt sich nicht um eine "hat-eine"-Beziehung, keines der Objekte ist Teil oder Mitglied eines anderen. Eine Assoziation bedeutet lediglich, dass sich die Objekte "kennen". Sie ist die schwächste Beziehung die ..

Das folgende Bild stellt die gerichtete Assozation "``Foo`` hat (kennt) ein ``Bar``" dar.

![Assoziation](/assets/img/uml/uml_elements-Assoziation.drawio.png){:width="60%"}
{:refdef}


Wenn man den Pfeil weglässt bedeutet das nur, dass sich beide Klassen gegenseitig kennen. Der Einfachheit halber bleibe ich hier beim Fall der gerichteten Assoziation.

**Alltagsbeispiel:** Arzt und Patient - Eine Klasse "Arzt" und eine Klasse "Patient" können eine gerichtete Assoziation haben. Ein Arzt kümmert sich um seine Patienten und kennt deren medizinische Geschichte, aber ein Patient kennt normalerweise nicht alle Details über seinen Arzt. In diesem Fall ist die Assoziation vom Arzt zum Patienten gerichtet.

## Implementierung

```c++
class Foo {
  Foo(Bar *bar) : bar_ptr(bar) {}
 
  void SetBar(Bar *bar) { bar_ptr = bar; }
 
  void F() { bar_ptr->FuncA(); }

  …

  Bar *bar_ptr; // pointer
};
```


# Aggregation

Die Aggregation ist eine spezielle Form der Assoziation, die eine "hat-ein" Beziehung darstellt. Ich habe ein Objekt, das ich mir von jemand anderem geliehen habe. Wenn das Objekt stirbt, kann ich weiterleben.

Das folgende Bild stellt die Aggregation "``Foo`` hat ein ``Bar``" dar.

![Aggregation](/assets/img/uml/uml_elements-Aggregation.drawio.png){:width="60%"}
{:refdef}


Eine Aggregation kann auftreten, wenn eine Klasse eine Sammlung oder ein Container für andere Klassen ist, die enthaltenen Klassen aber keine starke Abhängigkeit vom Container haben, d. h. wenn der Container zerstört wird, ist sein Inhalt nicht betroffen.

Möglicherweise verwechselst du Aggregation und Assoziation, denn der Unterschied ist nur logisch: nämlich ob das Objekt Teil des anderen ist oder nicht.


**Alltagsbeispiel:** Fußballteam und Spieler - Ein Fußballteam besteht aus vielen Spielern. In diesem Fall ist das Fußballteam das Ganze und die Spieler sind die Teile. Ein Fußballteam "hat" Spieler.

## Implementierung

Wie zuvor beschrieben unterscheiden sich die Implementierungen von Assoziation und Aggregation nicht. 

```c++
class Bar {
  …
}

class Foo {
public:
  Foo(Bar *bar) : bar_ptr(bar) {}
 
  void SetBar(Bar *bar) { bar_ptr = bar; }
 
  void F() { bar_ptr->FuncA(); }

  …

  Bar *bar_ptr; // pointer
};
```



# Komposition

Eine Komposition ist eine spezielle Form der Aggregation, die eine "besitzt-eine" oder "gehört-zu" Beziehung darstellt. Ich besitze ein Objekt und bin für seine Lebensdauer verantwortlich. Wenn das Objekt stirbt, sterbe auch ich.

Das folgende Bild stellt die Komposition "``Foo`` besitzt ein ``Bar``" dar.

![Komposition](/assets/img/uml/uml_elements-Komposition.drawio.png){:width="60%"}
{:refdef}


Sie ist eine starke Form der „hat-ein“ Beziehung, die impliziert, dass die Lebensdauer des Teil-Objekts (der „Besitz“) an die des Ganzen gebunden ist.

**Alltagsbeispiel:** Mensch und Herz - Ein Mensch hat ein Herz, und das Herz kann nicht ohne den Menschen existieren. Wenn der Mensch stirbt, stirbt auch das Herz. Hier ist die Komposition von der Klasse "Mensch" zur Klasse "Herz".

## Implementierung

```c++
// Example 1
class Foo {
public:
  Foo() : bar_ptr(nullptr) { bar_ptr = new Bar()}
  ~Foo() { delete bar_ptr; }
  …
private:
  …
  Bar *bar_ptr; // pointer
};

// Example 2
class Foo {
   …
   Bar bar;
}
```

# Generalisierung

Generalisierung ist ein anderer Begriff für Vererbung oder "ist-ein"-Beziehungen. 

Das folgende Bild stellt die Generalisierung "``Foo`` ist ein ``Bar``" dar.

![Generalisierung](/assets/img/uml/uml_elements-Generalisierung.drawio.png){:width="60%"}
{:refdef}

**Alltagsbeispiel:** Tier und Hund - Ein Hund ist ein Tier. In diesem Fall wäre "Tier" die Basisklasse und "Hund" wäre eine abgeleitete Klasse.


## Implementierung

```c++
class Bar {
public:
  ~virtual Bar() {};

  virtual void FuncA() { … /* Bar::FuncA implementation */ }
  virtual void FuncB() { … /* Bar::FuncB implementation */ }
  …
};

// Generalization of Bar
class Foo : public Bar{
public:
   virtual void FuncA() { Bar::FuncA(); … /* Foo::FuncA implementation */}
   virtual void FuncB() { Bar::FuncB(); … /* Foo::FuncB implementation */}
}

```

# Abhängigkeit

Abhängigkeiten in UML repräsentieren eine "benutzt-ein"-Beziehung zwischen zwei Klassen, bei der eine Änderung in einer Klasse Änderungen in der abhängigen Klasse erfordern kann. 

Das folgende Bild stellt die Abhängigkeit "``Foo`` benutzt-ein ``Bar``" dar.

![Abhängigkeit](/assets/img/uml/uml_elements-Abhängigkeit.drawio.png){:width="60%"}
{:refdef}

**Alltagsbeispiel:** Koch und Rezept - Ein Koch ist abhängig von einem Rezept, um ein Gericht zuzubereiten. Wenn das Rezept geändert wird (zum Beispiel die Zutaten oder die Zubereitungsanweisungen), muss der Koch seine Methode zum Zubereiten des Gerichts entsprechend ändern.

## Implementierung
```c++
class Foo {
 ...
 void F1(Bar y) {…; y.FuncA(); }
 void F2(Bar *y) {…; y->FuncB(); }
 void F3(Bar &y) {…; y.FuncC(); }
 void F4() { Bar y; y.FuncD(); …}
 void F5() {…; Y::StaticFunc(); }
 ...
};
```

# Realisierung

Eine Realisierung ist eine Beziehung zwischen zwei Klassen in UML, bei der eine Klasse die Implementierung oder das Verhalten, das durch eine andere Klasse oder in vielen Fällen durch eine Schnittstelle definiert ist, verspricht oder "realisiert". Man könnte sagen, dass es sich um eine "erfüllt-die"-Beziehung handelt.

Das folgende Bild stellt die Abhängigkeit "``Foo`` erfüllt das ``Bar`` Interface" dar.

![Realisierung](/assets/img/uml/uml_elements-Realisierung.drawio.png){:width="60%"}
{:refdef}


**Alltagsbeispiel:**  Es fällt schwer ein … Zum Beispiel, in der objektorientierten Programmierung, könnte eine Klasse eine Schnittstelle "Laufbar" implementieren, die eine Methode "laufen" definiert. Diese Klasse könnte ein "Hund", ein "Mensch" oder ein "Roboter" sein - alles, was "laufen" kann.

## Implementierung

```c++
// Abstract interface
class IBar {
  ~virtual IBar() {};

  …
  virtual void FuncA() = 0;
  virtual void FuncB() = 0;
};

// Realization of interface IBar
class Foo : public IBar{
   …
   virtual void FuncA() { … /* FuncA implementation */}
   virtual void FuncB() { … /* FuncB implementation */}
}

```

