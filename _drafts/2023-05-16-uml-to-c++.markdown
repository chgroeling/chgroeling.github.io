---
layout: single
toc: false
title:  "UML to C++"
date:   2023-05-16 06:00:10 +0200
categories: Software-Design
comments: true
---
{:refdef: style="text-align: center;padding: 20px"}

Ein UML-Klassendiagramm stellt die verschiedenen Klassen in einem System, ihre Attribute, Operationen und ihre Beziehungen zueinader dar. Da ich ein sehr "Code-lastiger" Mensch bin frage ich mich jedes mal wie ein 
dargestelltes Klassendiagramm letzlich in Code realisiert wird.  Dieser Artikel soll diese Fragestellung aufklären. Da ich Hauptberuflich im embedded Segment arbeite und wir dort C++ einsetzen möchte ich dies am Beispiel von C++ tun. Allerdings lassen sich die Erkenntnisse ohne weiteres auf andere Sprachen übertragen.

Der Artikel wendet sich an Entwickler die mit Klassendiagrammen schon Erfahrung haben. Allerdings glaube ich das auch Anfänger davon profitieren können wie ein Klassendiagramm letzlich in Code realisiert wird.

# Beziehungen

Bei richtiger Anwendung vermittelt UML präzise, wie Code aus Diagrammen implementiert werden sollte. Wenn ein Diagramm genau interpretiert wird, spiegelt es die Absicht des Design im Code korrekt wider. Das Kernelement hierbei sind die Beziehungen der Klassen zueinander. 

## Abhängigkeit

![Abhängigkeit]({{ site.url }}{{ site.baseurl }}/assets/img/uml/uml_elements-Abhängigkeit.drawio.png){:width="60%"}
{:refdef}

```c++
class X {
 ...
 void f1(Y y) {…; y.Foo(); }
 void f2(Y *y) {…; y->Foo(); }
 void f3(Y &y) {…; y.Foo(); }
 void f4() { Y y; y.Foo(); …}
 void f5() {…; Y::StaticFoo(); }
 ...
};
```

Abhängigkeiten in UML repräsentieren eine "benutzt-ein"-Beziehung zwischen zwei Klassen, bei der eine Änderung in einer Klasse Änderungen in der abhängigen Klasse erfordern kann. 

Koch und Rezept: Ein Koch ist abhängig von einem Rezept, um ein Gericht zuzubereiten. Wenn das Rezept geändert wird (zum Beispiel die Zutaten oder die Zubereitungsanweisungen), muss der Koch seine Methode zum Zubereiten des Gerichts entsprechend ändern.


### Assoziation mit Navigation

![Assoziation]({{ site.url }}{{ site.baseurl }}/assets/img/uml/uml_elements-Assoziation.drawio.png){:width="60%"}
{:refdef}

Arzt und Patient: Eine Klasse "Arzt" und eine Klasse "Patient" können eine gerichtete Assoziation haben. Ein Arzt kümmert sich um seine Patienten und kennt deren medizinische Geschichte, aber ein Patient kennt normalerweise nicht alle Details über seinen Arzt. In diesem Fall ist die Assoziation vom Arzt zum Patienten gerichtet.


Association is the weakest relationship between the three. It isn't a “has-a” relationship, none of the objects are parts or members of another.

Assoziation bedeutet lediglich, dass sich die Objekte gegenseitig "kennen". 

Ein Beispiel: eine Mutter und ihr Kind.

Die Assoziation ist die schwächste der drei Beziehungen. Es handelt sich nicht um eine "hat-eine"-Beziehung, keines der Objekte ist Teil oder Mitglied eines anderen.


Aber Moment mal, wie können wir feststellen, ob eine Referenz Aggregation oder Assoziation bedeutet?

Nun, das können wir nicht. Der Unterschied ist nur logisch: ob eines der Objekte Teil des anderen ist oder nicht.

Außerdem müssen wir die Verweise auf beiden Seiten manuell pflegen, wie wir es bei der Aggregation getan haben:
class Child {}

```c++
class Mother {
List<Child> children;
}
```

Ein Objekt weiß von einem anderen; es enthält einen Zeiger oder Verweis auf ein anderes Objekt.

Assoziation - Ich habe eine Beziehung zu einem Objekt. Foo verwendet Bar

```c++
public class Foo {         
    private Bar bar;
};
```


### Aggregation

![Aggregation]({{ site.url }}{{ site.baseurl }}/assets/img/uml/uml_elements-Aggregation.drawio.png){:width="60%"}
{:refdef}

Die Aggregation ist eine spezielle Form der Assoziation, die eine "hat-ein" Beziehung darstellt. 

Fußballteam und Spieler: Ein Fußballteam besteht aus vielen Spielern. In diesem Fall ist das Fußballteam das Ganze und die Spieler sind die Teile. Ein Fußballteam "hat" Spieler.

Eine Aggregation kann auftreten, wenn eine Klasse eine Sammlung oder ein Container für andere Klassen ist, die enthaltenen Klassen aber keine starke Abhängigkeit vom Container haben, d. h. wenn der Container zerstört wird, ist sein Inhalt nicht betroffen. Möglicherweise verwechseln Sie Aggregation und Assoziation, denn die Assoziation unterscheidet sich von der Aggregation nur dadurch, dass sie kein Containment voraussetzt.

Aggregation - Ich habe ein Objekt, das ich mir von jemand anderem geliehen habe. Wenn Foo stirbt, kann Bar weiterleben.

```c++
public class Foo { 
    private Bar bar; 
    Foo(Bar bar) { 
       this.bar = bar; 
    }
}
```

```c++
class Window
{
 public:
  //...
 private:
 vector itsShapes;
};
``` 

### Generalisierung

![Generalisierung]({{ site.url }}{{ site.baseurl }}/assets/img/uml/uml_elements-Generalisierung.drawio.png){:width="60%"}
{:refdef}

Tier und Hund: Ein Hund ist ein Tier. In diesem Fall wäre "Tier" die Basisklasse und "Hund" wäre eine abgeleitete Klasse.

Generalisierung ist ein anderer Begriff für Vererbung oder "ist-ein"-Beziehungen. 


### Komposition

![Komposition]({{ site.url }}{{ site.baseurl }}/assets/img/uml/uml_elements-Komposition.drawio.png){:width="60%"}
{:refdef}

Eine Komposition ist eine spezielle Form der Aggregation, die eine "besitzt-eine" oder "gehört-zu" Beziehung darstellt. Sie ist eine starke Form der "hat-ein" Beziehung, die impliziert, dass die Lebensdauer des Teil-Objekts (der "Besitz") an die des Ganzen gebunden ist.

Mensch und Herz: Ein Mensch hat ein Herz, und das Herz kann nicht ohne den Menschen existieren. Wenn der Mensch stirbt, stirbt auch das Herz. Hier ist die Komposition von der Klasse "Mensch" zur Klasse "Herz".

class Circle
{
private:
     ...
    Point center;
....
};

Komposition - Ich besitze ein Objekt und bin für seine Lebensdauer verantwortlich. Wenn Foo stirbt, stirbt auch Bar
public class Foo {
    private Bar bar = new Bar(); 
}

### Realisierung

![Realisierung]({{ site.url }}{{ site.baseurl }}/assets/img/uml/uml_elements-Realisierung.drawio.png){:width="60%"}
{:refdef}

Eine Realisierung ist eine Beziehung zwischen zwei Klassen in UML, bei der eine Klasse die Implementierung oder das Verhalten, das durch eine andere Klasse oder in vielen Fällen durch eine Schnittstelle definiert ist, verspricht oder "realisiert". Man könnte sagen, dass es sich um eine "erfüllt-die"-Beziehung handelt.

Zum Beispiel, in der objektorientierten Programmierung, könnte eine Klasse eine Schnittstelle "Laufbar" implementieren, die eine Methode "laufen" definiert. Diese Klasse könnte ein "Hund", ein "Mensch" oder ein "Roboter" sein - alles, was "laufen" kann.

Fall 1: Wenn X einen Vektor enthält, handelt es sich um eine Komposition;
Fall 2: Wenn X einen Vektor enthält und die Konstruktion und Zerstörung von Y* innerhalb von X (im Konstruktor/Destruktor) stattfindet, handelt es sich um eine Komposition.
Fall 3: Wenn X einen Vektor enthält und der Aufbau und die Zerstörung von Y* nicht innerhalb von X (im Konstruktor/Destruktor) stattfindet, kann es sich je nach Szenario um eine Aggregation/Aggregation handeln.


